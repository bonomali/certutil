package cmd

import (
  "fmt"
  "log"
  "strings"
  "os"
  "os/user"
  "io/ioutil"
  "github.com/codegangsta/cli"
  "crypto/rsa"
  "../cert"
)

type LocalEnvironment struct {
  host string
  user string
}

func getLocalEnvironment () LocalEnvironment {
  // Acquire Hostname
  host, err := os.Hostname()
  if err != nil {
    fmt.Println(err)
  }

  // Acquire the current user
  user, err := user.Current()
  if err != nil {
    fmt.Println(err)
  }

  return LocalEnvironment{
    host: host,
    user: user.Username,
  }
}

func NewCertificate () cli.Command {

  local := getLocalEnvironment()

  return cli.Command{
    Name: "create",
    Aliases: []string{"c"},
    Usage: "Create a certificate.",
    Flags: []cli.Flag{
      cli.StringFlag{
        Name: "passphrase, p",
        Usage: "Optional PEM encryption key.",
      },
      cli.IntFlag{
        Name: "bits, b",
        Value: 2048,
        Usage: "Keypair bit size.",
      },
      cli.IntFlag{
        Name: "expire, e",
        Value: 3650,
        Usage: "Expiration in days (10yrs by default).",
      },
      cli.StringFlag{
        Name: "key, k",
        Usage:"Private key file. Key is autogenerated if this is left blank.",
      },
      cli.StringFlag{
        Name: "certauth, ca",
        Value: "self",
        Usage: "Signing certificate (CA). If this is not specified, the certificate will be self-signed.",
      },
      cli.StringSliceFlag{
        Name: "email",
        Value: &cli.StringSlice{},
        Usage: "Optionally specify the email address of the certificate admin. This can be specified multiple times.",
      },
      cli.StringFlag{
        Name: "output, dir",
        Usage:"Output directory where the certificate and private key are stored.",
      },
      cli.StringFlag{
        Name: "org, o",
        Value: local.user + " computer",
        Usage: "Organization",
      },
      cli.StringFlag{
        Name: "orgunit, ou",
        Value: "localhost",
        Usage: "Organizational Unit",
      },
      cli.StringFlag{
        Name: "country, c",
        Value: "Earth",
        Usage: "Country",
      },
      cli.StringFlag{
        Name: "commonname, cn",
        Value: local.host,
        Usage: "Common Name",
      },
      cli.StringFlag{
        Name: "state, s",
        Value: "Unknown",
        Usage: "Province, Region, County or State",
      },
      cli.StringFlag{
        Name: "city, l",
        Value: "Unknown",
        Usage: "Town/City/Locality",
      },
      cli.StringSliceFlag{
        Name: "san",
        Value: &cli.StringSlice{},
        Usage: "A domain or IP address associated with the certificate (Subject Alternative Name). Declare a new argument for each domain/IP.",
      },
    },
    Action: MakeCertificate,
  }
}

func stringInSlice(str string, list []string) bool {
  for _, v := range list {
    if v == str {
      return true
    }
  }
  return false
}

func deduplicate (slice []string) []string {
  cleaned := []string{}
 	for _, value := range slice {
 		if !stringInSlice(value, cleaned) {
 			cleaned = append(cleaned, value)
 		}
 	}
  return cleaned
}

func MakeCertificate (c *cli.Context) {
  cn := c.String("commonname")
  cn = strings.Replace(cn, " ", "_", -1)

  // If no private key is specified, make one.
  var pk *rsa.PrivateKey
  if !c.IsSet("key") {
    pk = cert.CreatePrivateKey(2048)
  } else {
    pk = cert.ReadPrivateKey(c.String("key"))
  }

  // Create a CSR struct
  csr := cert.CSR{
    CA: false,
    Passphrase: c.String("passphrase"),
    Size: c.Int("bits"),
    Days: c.Int("expire"),
    Key: pk,
    CN: cn,
    O: c.String("org"),
    OU: c.String("orgunit"),
    C: c.String("country"),
    S: c.String("state"),
    L: c.String("city"),
  }

  if c.IsSet("email") {
    csr.Email = deduplicate(c.StringSlice("email"))
  }

  var slice []string
  if c.IsSet("san") {
    slice = c.StringSlice("san")
  }

  if c.IsSet("certauth") {
    if !c.IsSet("key") {
      log.Fatalf("--key or --k is required when using --certauth or --ca. (Private Key Not Found)")
    }
    csr.SignCert = c.String("certauth")
    csr.SignKey = c.String("key")
    slice = append(slice, "localhost", "127.0.0.1")
  } else {
    csr.CA = true
  }

  csr.Domains = deduplicate(slice)

  certificate, privatekey := cert.Make(csr)

  if !c.IsSet("output") {
    fmt.Print(string(certificate))
    fmt.Print(string(privatekey))
  } else {
    filepath := c.String("output") + "/" + cn
    ioutil.WriteFile(filepath + ".crt", certificate, 0600)
    ioutil.WriteFile(filepath + ".key", privatekey, 0600)
  }
}
